## 其他

- 基础知识
- 通用知识
- 专用知识（知道干甚的即可）

### 方向

优先做：
1、系统的优化体验（这个可以很快完成）
2、构建这块，vite，snowpack等，开发环境做编译优化工作
3、React架构（一套解决方案），持续产出
4、webComponent，深挖，实践，落地一些东西，为后续做准备；先做初版实践，再慢慢的迭代

- 项目体验，项目提效（开发那么久，时间都耗在哪里了？怎么结局），质量，通过自动化工具去实现
- css模块化，stylus
- 加载及性能优化等
- 跨端的flutter，
- 项目上的赋能，暂时有个菜谱的项目，兵哥他们正在谈

- Fedaas前端分布式服务
    - 如何参与进去？
    - 每个人都需要做哪些工作

- 微前端
    - 自己写loader配合systemjs，singleSpa
    - 使用乾坤

- React相关
    - 新旧架构对比以及部分核心细节点
    - 结合项目，梳理常见的技术点
    - 产出类似ahook类的适用于咱公司项目的hooks集
    - 或者一些最贱实践

- 产出一个类似lodash的工具集
    - 前期可以抽出npm包，
    - 后续可以考虑界面化操作，支持录入新的工具函数或测试用例等

- BFF、mysql，redis，websocket等。
- typescript方面，
- 构建这块，vite，snowpack -> esbuild
- 编译原理相关
- docker容器，容器云，kubernetes，nginx等
- 监控方面
- Devops到NoOps -》serverless相关-》midway
- GraphQL相关
- ssr相关，服务端推送等等
- css相关，原子类css，tailmind css
- WebAssembly
- no-code、low-code平台
- ssr，next.js服务端渲染
- vscode插件，Electron等

### umijs

[umi官网](https://umijs.org/zh-CN/docs/getting-started)

我们在“刀耕火种”的时代做前端开发的时候，总是会考虑我们选择在项目里使用 React 库来开发的时候，项目的数据流方案应该怎么选择（redux, mobx, redux-saga, redux-router,dva,等），组件库 的选择（antd, material design），以及webpack打包的复杂配置等，这里的 Bigfish&um看起来像是把以前我们项目中通常会用到的一些库整合到了一起。

既然Umi是一个框架，那就有很多“约定”的规则，需要我们遵守，不管是在路由配置，还是在mock数据，以及数据和页面交互方面，我们都能够感受到这种潜在的“约定”。
### css技巧

[10个css技巧网站](https://mp.weixin.qq.com/s/qwfPlfoWKUWHdY3pTp7gCQ)
[十天精通css3](https://www.imooc.com/learn/33)
[css的一些效果库：you need to know css](https://lhammer.cn/You-need-to-know-css/#/zh-cn/blink)
### svelte
Svelte是一个用 TypeScript 编写的下一代轻量级组件框架，它提供了一种创建高性能 Web 应用的新方法。与更流行的框架 React 和 Vue.js 不同，它不是在运行时将应用转换为普通 JS 代码，而是在构建时完成。换句话说，作为一个编译器，Svelte 可以在没有任何抽象层的情况下在浏览器中运行代码，提高了应用程序的性能，并提供了更好的用户体验。

因此，在第一次加载时，使用 Svelte 创建的 Web 应用程序就比基于其他框架的应用程序要快得多。Svelte 可以单独使用，也可以与其他框架结合使用来生成 Web 应用程序。


### deno
2020 年，Web 开发人员得到了一个新的功能强大的工具，让他们可以在服务器端实现自己的代码——Deno。这是一个用 Rust 编写的新的运行时环境，它利用了 V8 JS 引擎和内置的 TypeScript 支持。

Deno 的主要意图是克服 Node.js 的主要缺点，如安全漏洞和包管理问题，并利用现代 JavaScript 的特性。它附带了许多集成工具，可以方便开发人员进行测试、调试和格式化。

Deno 的出现并不意味着 Node.js 已经走到了尽头，因为它仍然是一个被广泛使用、有良好支持的环境。


### next.js

前端项目大方向上可以分为两种模式：前台渲染和服务端渲染。

前台渲染-SPA应用是一个主要阵营，如果说有什么缺点，那就是SEO不好。因为默认的HTML文档只包含一个根节点，实质内容由JS渲染。并且，首屏渲染时间受JS大小和网络延迟的影响较大，因此，某些强SEO的项目，或者首屏渲染要求较高的项目，会采用服务端渲染SSR。

Next.js 是一个轻量级的 React 服务端渲染应用框架。
 
熟悉React框架的同学，如果有服务端渲染的需求，选择Next.js是最佳的决定。

- 默认情况下由服务器呈现
- 自动代码拆分可加快页面加载速度
- 客户端路由（基于页面）
- 基于 Webpack 的开发环境,支持热模块替换（HMR）

### nestjs

Nest (NestJS) 是一个用于构建高效、可扩展的Node.js服务器端应用程序的开发框架。它利用 JavaScript 的渐进增强的能力，使用并完全支持TypeScript（仍然允许开发者使用纯 JavaScript 进行开发），并结合了 OOP （面向对象编程）、FP （函数式编程）和 FRP （函数响应式编程）。

注意与nextjs是不相同的。 
- Next是一个React框架，允许使用React构建SSR和静态web应用
- Nuxt是一个基于Vue的通用应用框架，预设了利用Vue开发服务端渲染的应用所需要的各种配置，主要关注的是应用的UI渲染
- Nest 是一个用于构建高效，可扩展的 Node.js 服务端应用程序的渐进式框架。


Nest 是一个用于构建高效，可扩展的 Node.js 服务端应用程序的渐进式框架。它是基于 TypeScript 编写的，并且结合了 OOP（面向对象编程），FP（函数式编程）和FRP（函数响应式编程）的元素，同时也支持现代化的 Web 开发工具和设计模式。

Nest 采用模块化的结构，具有可插拔的体系结构，使开发人员可以轻松组合不同的库和工具，同时保持应用程序的清晰和结构良好。它还提供了强大的依赖注入和测试支持，使开发人员可以编写可维护，可测试的代码。

Nest 主要用于构建 Web 服务器，但也可以用于构建命令行工具、微服务和 IoT（物联网）应用程序等。它是一个开源项目，由社区驱动，并且在 GitHub 上有广泛的文档和示例代码。

[三者对比](https://blog.fundebug.com/2019/05/23/next-nuxt-nest/)
Next、Nuxt和Nest。这三个框架都是服务器端渲染，它们分别与React、Vue和Angular(三个目前最流行的前端框架)密切相关
### WebAssembly

[参考](https://developer.mozilla.org/zh-CN/docs/WebAssembly)

WebAssembly是一种新的编码方式，可以在现代的网络浏览器中运行 － 它是一种低级的类汇编语言，具有紧凑的二进制格式，可以接近原生的性能运行，并为诸如C / C ++等语言提供一个编译目标，以便它们可以在Web上运行。它也被设计为可以与JavaScript共存，允许两者一起工作。


### tailwindcss

Tailwind CSS 是一个功能类优先的 CSS 框架，它集成了诸如 flex, pt-4, text-center 和 rotate-90 这样的的类，它们能直接在脚本标记语言中组合起来，构建出任何设计。

其实相当于定义好了css的一些样式类，直接使用实现想要的效果。明明方式值得借鉴

### serverless

Devops(software development (Dev) and IT operations (Ops).)到NoOps -》serverless相关

### midwayjs

Midway 2.0 集成了 Serverless 能力，同时扩展了 RPC、Socket、微服务、前后端一体化研发等能力，不同的场景之间可以组合、协作，给用户提供相对灵活又可靠的使用体验。

社区上也有很多类似的框架，那为什么还需要 Midway ？

原因有三点

1、Midway 是阿里内部一直持续在研发的框架，之前 egg 是作为底层框架，需要有面向应用层面的框架来和集团场景对接
2、全量使用 TypeScript 是未来一段时间的趋势，面向未来去迭代和研发是作为架构组创新的要求
3、虽然社区已经有 nest 这样的框架，但是这些产品的维护、协作、修改都会到商业化产品的制约，也无法做到需求的快速迭代和安全性保障，整体的研发理念也和我们不同，为此，我们需要有一套自研的框架体系
### webgl

月影表示自己这两年的主要精力放在可视化领域，主要是可视化渲染方面，他认为可视化是值得前端工程师重视的一个领域。随着 Web 技术的发展，视觉特别是 WebGL/GPU 相关的应用场景会越来越丰富，对技术要求也会越来越高。与前端其他大部分技术不同，WebGL 的上手门槛比较高，需要对数学、图形学有比较扎实的基础，而图形学和视觉呈现技术本身的天花板非常高，未来这块一定会有非常大的发展空间。

对于一些前端开发的担忧，他也能够理解。他认为，如果你 不盲目 地去追求所谓的“时髦”技术，不去刻意担心自己是否落伍，而是去多观察这个行业，找到技术发展内在的规律和脉络，那么你就知道该如何前进，不会有任何恐慌。



在任何一个领域或方向，知识体系都可以大体上分为基础知识和领域知识，而领域知识又可以分为通用领域知识和专用领域知识。二者的变化是不一样的，基础知识的变化最慢，其次是通用领域知识，然后是专用领域知识。



用可视化这个方向来举例，基础知识是数学和图形学知识，比如向量、矩阵运算、三角剖分这些知识属于基础知识，它们基本上不会随着时间发生很大变化。JavaScript、WebGL 这种属于通用领域知识，它们会改变，会慢慢发展，比如从 WebGL1.0 发展到 WebGL2.0，从 ES2019 发展到 ES2020，但不会变化、发展得那么快。而类似 ThreeJS、BabylonJS、SpriteJS、d3.js，这些属于专用领域知识，很有可能一个大版本升级，就会有很大的变化。



学习这些知识，也是有不同的方法的。一般来说，如果是基础知识，随便什么时候都可以学，而且越早学习越好。基础知识就像是你的内功，学好它们，融会贯通之后，学习其他的知识都是事半功倍的。如果是通用的领域知识，一旦你下决心从事这个领域，也是能够尽早学习它比较好，不过由于这些知识是领域相关的，如果能一边学习，一边通过实践来打磨，就会掌握得更快。专用领域知识，不一定要很早去学，有一个技巧是，当你用到的时候再去学习它们。如果你没有用到，你可以知道有这门技术，能做什么就行了，不用花大量时间和精力去钻研它们。



有些同学觉得技术更新太快，学不过来，通常是被这些专用领域知识给“迷惑”了。比如大家都说前端工程化里的代码打包很重要，于是今天学习了 webpack，明天又去学习 rollup，而实际上这种专用领域知识，只需要知道它们能做什么，在用到的时候再去详细学习就好了。
## 数据库

[GraphQL](https://graphql.cn/learn/) 是一个用于 API 的查询语言，是一个使用基于类型系统来执行查询的服务端运行时（类型系统由你的数据定义）。GraphQL 并没有和任何特定数据库或者存储引擎绑定，而是依靠你现有的代码和数据支撑。

## 微前端

2018年 Single-SPA诞生了， single-spa 是一个用于前端微服务化的 JavaScript 前端解决 方案 (本身没有处理样式隔离， js 执行隔离) 实现了路由劫持和应用加载(即根据不同的路由加载不同的应用)

2019年 qiankun 基于Single-SPA, 提供了更加开箱即用的 API （ single-spa + sandbox + import-html-entry ）做到了，技术栈无关、并且接入简单（像i frame 一样简单）

systemjs的官方定义是为浏览器中的ES模块启用向后兼容工作流和可配置的模块加载程序，说的简单点就是让你可以在浏览器中使用上述说的几种任意的模块化方式。因为要动态通过http引入外部js，又不影响在开发的时候使用import、require方法，所以找到了systemjs来做这件事。-》SystemJS是一个可运行于浏览器端的模块加载器，是一个polifill，可以让我们在浏览器上直接使用ES模块等先进语法，而不用管浏览器是否支持该语法。

对应的，SystemJS有一个运行于Nodejs的版本：system-node.cjs。[参考](https://champyin.com/2021/03/05/SystemJS/)

注意_加载_和_打包_模块之间的一些关键区别很重要。可以在 JSPM 引擎下找到像 SystemJS 的工具，**用于在浏览器通过运行时(runtime)来加载和转译模块**。这和 webpack 的在加载到浏览器之前，模块就已经被转译（通过 "loaders"）并打包在一起显著不同。

每种方法都有其优势和劣势。运行时(runtime)加载和转译模块，为大型网站增加了大量开销，并且应用程序会由许多模块组成。因此，SystemJS 对于需要少量模块的小型项目更有意义。但是，随着 HTTP/2 改善文件从服务器到客户端的传输速度，这可能会发生一些变化。请注意，HTTP/2 不会修改_转译_模块的任何内容，在客户端下载完成后，还是需要很长时间去进行转译。
### 相关链接

- [前端微服务解决方案集合](https://alili.tech/archive/ea599f7c/)
- [每日优鲜微服务改造](https://juejin.cn/post/6844903943873675271)
- 

## 前端破局

理解需求并不等于理解业务，需求是业务经过产品消化后的产物，可能已经经过演绎或者拆解，因此需求并不是业务本身，当然了解的需求越多，对业务的全貌也会更加了解。

## rust
云原生时代，Go 语言凭借其原生支持高并发等特性，一跃成为云原生基层设施建设首选语言，荣登各大编程语言排行榜前列，成为用户增长最快的新兴编程语言之一。而相比之下，同样以取代 C/C++为目的被创造出来的另一门新语言 Rust 在很长一段时间里则不温不火，陷入“叫好不叫座”的尴尬境地。

[rust应用前景](https://www.zhihu.com/question/30407715)


## 尤雨溪
1、想要最大化创造价值，最重要的是两点。第一，会发现问题，并且判断出什么问题值得解决。第二，具备高质量解决某个领域问题的技术水准。



2、为什么程序员不自己单干？可以啊，那些说难的，就是能力不够罢了（不一定是技术能力）。



3、先问是不是，再问为什么。大部分 “我身边...” 开头的回答都是以偏概全的，只有数据才会给你真相。



4、英语是否会成为开发工程师的发展瓶颈？回答：不仅英语差会成为瓶颈，英语好还能成为优势，因为学习效率会比别人高。像我这样半路出家自学的人，只能靠英语了...



5、很多非科班出身的程序员经常会潜意识里给自己划定范围，啊这个是科班出身的人才懂的东西，我没希望了。你之前学了啥跟你以后能学啥没有什么本质联系吧。我本科学的是艺术史，只意味着我本科的时间大部分花在了艺术史上而已，不代表我以后不能再花时间在 CS 的东西上。其实很多所谓科班出身的人对于编译原理的理解跟你的差别也就是三个多月一门课而已... 如果真的觉得编译原理是自己的瓶颈了，那就下决心去学呗，可能并没你想象的那么可怕。



6、前端开发中有什么经典的轮子值得自己去实现一遍？答：Virtual-DOM。



7、有什么适合碎片时间看的计算机基础书籍推荐？答：学 JavaScript 碎片时间看犀牛书正好。我当年就是在公交车上看完的。



8、一直呆在舒适区往往就得不到提升，程序员能力的提升往往都发生在尝试解决一个从没解决过的问题之后进行反思的过程中。



9、前端这个词现在涵盖的内容也越来越广了，尤其是应用化了以后，俨然前端自己有一个迷你技术栈。我来简单勾勒下：

纯表现层。用户体验、布局、特效、研究 CSS 各种奇技淫巧，对于很多设计 / 前端兼修的人来说，技术层面就到此为止了。他们很多可能一辈子都不会写翻转二叉树，但他们也能搞出一些科班出生的人一辈子也搞不出的用户体验。当然不排除一些走 creative coding / 数据可视化路线的人需要对物理、数学、甚至计算机图形方面的知识进行针对性地强化。

应用实现层。可能是大公司初级工程师主要干的活：拿着别人设计好的框架、工具去实现具体的应用逻辑。实话实说这个层面对计算机基础的要求确实不高，只要对 JavaScript、CSS 这些领域专门的东西基础扎实 + 学习能力 OK 就可以了。但是这个层面其实需求巨大，而且有一个独特的需求：开发效率。要提升效率就得对手上的工具了解得非常细致，比如 XX 框架的 N 种优化小窍门之类的。而这种东西只能靠实战经验去积累，基础再扎实影响也有限。

应用架构层。技术选型、开发底层框架、制定开发规范、设计应用结构... 这些东西就涉及到知识的广度和深度了，对业务需求的理解很重要，而且碰到具体的纯技术问题的可能性也大得多。编译原理、算法、数据结构在这里都会派上实际的用处。

基础设施层。自动化构建、部署、测试、加载方案、性能优化、代码质量管理等等... 这一层更加技术化了，而且涉及很多所有软件工程共通的东西，并不局限于前端。

理念层。通过借鉴整个计算机体系中其他领域的思想，从根本上改进前端的开发范式。Facebook 的人现在做的就是这种事情。事实上能做到这一层的人基本不以前端自居了。



上面的这些层次并不是一个发展路线，不是说是个前端就一定要冲着最高的层次去，这不现实，因为每个层次都可以深入钻研，对于公司来说，**尤其是大公司，往往更需要在一个层次深入专精的人而不是每个层次都半桶水的人（对于多层次专精的人的需求也是有的，**但是这种一般都是 senior 职位了，不会太多）。



10、不看具体业务需求就谈一个前端是不是靠谱都是耍流氓。一个人称不称职，看的是他的技能树和他当前的职责是否匹配。有没有必要学习特定的知识，这是一个要看情况讨论的问题。假如一个人科班出身，基础扎实来做前端，那他可能很快就可以开始涉及架构层和基础设施层的工作，这是比较理想的情况。但如果之前并没有基础，那就看你有没有野心向其他层去发展了，如果你真的有兴趣，在研究过程中自然会发现自己的短板，并且有足够的动力去弥补它。


11、一个框架能不能火，最关键的不是技术实现上多 nb，而是在于这个框架是否代表了一种（在其所处的时代）先进的开发理念。


以上内容，来自尤雨溪的知乎。另外，5 月 9 日（周日）晚上 21:00，我会连麦尤大，和你聊聊 Vue 3.0、Vite，以及最近他看到的前端新趋势，记得预约（没有广告，全是干货）。