---
layout: post
title: shell
date: Fri May 10 2019 17:25:32 GMT+0800 (中国标准时间)
---

### shell 整理版本二

#### shell 语法

#### 命令行工具

```bash
# 当执行下面命令时，一般执行的是package.json的scripts字段里的值
npm i

# 但是若在一个没有package.json的文件夹里执行 npm i，会提示如下：
# 其实就是提示没有package.json，并新建了package-lock.json
# 同时警告没有对应的几个字段信息
npm WARN saveError ENOENT: no such file or directory, open 'xxx/package.json'
npm notice created a lockfile as package-lock.json. You should commit this file.
npm WARN enoent ENOENT: no such file or directory, open 'xxx/package.json'
npm WARN xxx No description
npm WARN xxx No repository field.
npm WARN xxx No README data
npm WARN xxx No license field.

# 但是有时候，需要别人也能使用一些封装的命令行工具，此时就需要发npm包
# 常用commander来开发命令行工具
```

### shell 整理版本一

#### shell 的基本概念

在计算机科学中，壳层（shell）指为用户提供用户界面的软件，通常指的是命令行界面的解析器。一般来说，这个词是指操作系统中提供访问内核所提供之服务的程序。

其实 shell 就是一种应用程序，通过它可以访问操作系统内核的服务。而 shell 脚本，是专门为特定 shell 编写的脚本程序。

shell 编码和 js,java,php 等编程一样，只要有一个**编写代码的文本编辑器**和一个**能解释执行的脚本解析器**就可以了，文本编辑器可以理解为 IDE 或 Vim,vi,Emacs 等，但后者更单纯一些

**_为何要学 shell_**<br/>

1. 环境兼容性，Win7 专业版和旗舰版默认安装 PowerShell，标准版和家庭版中就没有安装的，其他主流的操作系统都预制了 Shell 解释器，所以使用 sh、bash 编写，提供给其他人使用是非常方便的，但是 PHP、Python 等等需要安装相应的环境
2. 如果你想做一些定时任务比如说检测进程是否存在，自动备份，或者说自动部署环境、服务器之间的数据同步等等 sh、bash 会是你最好的选择

**_shell 解析器_**<br/>
但 shell 也泛指所有为用户提供操作系统的程序，因此可以分成两类：

1. 命令行界面（CLI，command line interface）
   - Bourne shell (sh) 1. Bourne-Again shell (bash) 2. Z shell (zsh) 3. ...
   - C shell (sh)
   - ...
2. 图形用户界面（GUI，graphical user interface）
   - DOS Shell
   - Macintosh Finder
   - ...

bash 作为 Unix shell 的一种，是 sh 的后继兼容版本与开放源码版本，语法及特性大多借鉴于 sh,csh，ksh 等。计划用在 GNU 操作系统上，但能运行在大多数类 Unix 系统的操作系统上，包括 linux，Mac os x v10.4 都将它作为默认 shell。

bash 是一个命令处理器，通常运行于文本窗口中，并能执行用户直接输入的命令。bash 还能从文件中读取命令，这样的文件成为**脚本**

在 Linux 系统中一切都是文件，Linux 命令也不例外。那么用户执行一个命令后，linux 系统中到底发生了什么事情呢？简单来说，命令 linux 中的执行分为 4 个步骤：

1. 判断用户是否以绝对路径或相对路径的方式输入命令，如果是的话则直接执行
2. linux 系统检查用户输入的命令是否为别名系统（即 alias 等别名）
3. bash 解释器判断用户输入的是内部命令还是外部命令，内部命令可以直接执行，外部命令则需要进一步处理
4. 系统在多个路径中查找用户输入的命令文件，而定义这些路径的变量叫做 PATH,可以简单地把他理解成解释器的小助手，作用是告诉 bash 解释器待执行的命令可能存放的位置，然后 bash 解释器就会乖乖地在这些位置逐个查找。

既然命令也需要路径指向它，为何不将当前目录(.)添加到 PATH 中呢？原因是，尽管可以将当前目录添加到 PATH 变量中，从而在某些情况下可以让用户免去输入命令所在路径的麻烦，但是，如果黑客在比较常用的公共目录/tmp 中存放一个与 ls,cd 命令同名的木马文件，而用户又恰好在公共目录中执行了这些命令，那么就极有可能中招了。

在 linux 系统中一切皆文件，而配置一个服务就是在修改其配置文件的参数。配置网络服务的工作其实就是在编辑网卡配置文件，在 RHEL5（`Red Hat Enterprise Linux（RHEL）是一个由 Red Hat 开发的商业市场导向的 Linux 发行版`）,RHEL6 中，网卡配置文件的前缀为 eth，第一块网卡为 eth0,第二块网卡为 eth1，依次类推。

在终端输入：sh 后，需要`ctrl+d或exit`才能退出，而不是其他的`ctrl+c`

**mac 环境变量**  
参考：[mac 下环境变量设置][macenviromentset]

**环境变量**：  
变量是计算机系统用于保存可变值的数据类型。在 linux 系统中，变量名通常都是大写的，这是一种约定俗成的规范。linux 系统中的环境变量是用来定义系统运行环境的一些参数，比如每个用户不同的家目录，邮件存放的位置等。

```bash
# env 可以查看所有环境变量
env

# 查看PATH环境变量
echo $PATH
/Users/mac/.npm-global/bin:/Users/mac/.npm-global/bin:/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin
# 查看配置的.zshrc里有下面一行代码，和上面第一个环境变量相同
export PATH=~/.npm-global/bin:$PATH

# 查看默认shell类型
# 不同的shell读取的配置文件不同，因此配置环境变量时需要配置到对应shell的配置文件里
echo $SHELL
=> /bin/zsh

# 查看系统里安装了哪些shell
cat /etc/shells
/bin/bash
/bin/csh
/bin/ksh
/bin/sh
/bin/tcsh
/bin/zsh

# 更改默认的shell
# 所谓默认的shell就是打开终端或切换tab时自动加载的那个shell
# 当然，若不想更改默认的shell，但想进入某种shell的环境，可以直接输入bash进入bash环境
# 和终端直接输入node进入node环境类似，但不同，node属于repl模式，还是模仿shell的
# python、ruby等脚本语言大多也都有个repl
chsh -s $(which zsh)
# 其实$(which zsh)就是zsh的绝对路径
echo $(which zsh)
/bin/zsh

# 查看用户家目录(其实就是~的上一级)
echo $HOME
=> /Users/mac
```

**mac 启动时加载的配置文件位置(可设置环境变量)**：

```bash
# （1）首先要知道你使用的Mac OS X是什么样的Shell，使用命令
echo $SHELL
# 如果输出的是：csh或者是tcsh，那么你用的就是C Shell。
# 如果输出的是：bash，sh，zsh，那么你的用的可能就是Bourne Shell的一个变种。

# Mac OS X 10.2之前默认的是C Shell。
# Mac OS X 10.3之后默认的是Bourne Shell。

# （2）如果是Bourne Shell。
# 那么你可以把你要添加的环境变量添加到用户主目录(~)下面的.profile或者.bash_profile，
# 如果存在没有关系添加进去即可，如果没有生成一个。

# Mac配置环境变量的地方
#  1./etc/profile   （建议不修改这个文件 ）
#  全局（公有）配置，不管是哪个用户，登录时都会读取该文件。

#  2./etc/bashrc    （一般在这个文件中添加系统级环境变量）
#  全局（公有）配置，bash shell执行时，不管是何种方式，都会读取此文件。

#  3.~/.bash_profile  （一般在这个文件中添加用户级环境变量）
#  每个用户都可使用该文件输入专用于自己使用的shell信息,当用户登录时,该文件仅仅执行一次!

# 务必注意：上面虽然说zsh用的是Bourne Shell，
# 但却不读取.profile或者.bash_profile配置文件，
# 因此若将环境变量添加至这两个里面，会提示command not found
# 也悟出一个道理：command not found一定是可执行程序的路径没找到，也就是环境变量没有被正确读取。

# 那为何？之前我把环境变量配置在.profile里，使用source .profile后，再执行eslint命令，能正确执行呢？
# 因为source .profile不但会执行.profile里的逻辑，同时把该文件当做配置去执行，因此配置在.profile的环境变量就会被读取到。

# 上面摘自某论坛，但可靠性不足，因此若想可靠地分析分析，还是需要用man
# 在终端下，大多程序的快捷键会是三者之一：
# 1. vi风格，比如vi系列、less；
# 2. emacs风格，比如emacs系列、bash、zsh；
# 3. 自己的奇葩风格，但依然支持小部分emacs风格，比如nano、整个mac系统
# 因此可以直接：man zsh ，然后直接输入：/.zshrc，就可以搜索对应关键词（cmd+f搜索的是可见区域）
# 参考：https://wiki.archlinux.org/index.php/Zsh_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)
```

**#! Shebang**  
在计算机科学中，Shebang（也称为 Hashbang ）是一个由井号和叹号构成的字符序列 #! ，其出现在文本文件的第一行的前两个字符。 在文件中存在 Shebang 的情况下，类 Unix 操作系统的程序载入器会分析 Shebang 后的内容，将这些内容作为解释器指令，并调用该指令，并将载有 Shebang 的文件路径作为该解释器的参数。

Shebang 这一语法特性由 #! 开头，即井号和叹号。 在开头字符之后，可以有一个或数个空白字符，后接解释器的绝对路径，用于调用解释器。 在直接调用脚本时，调用者会利用 Shebang 提供的信息调用相应的解释器，从而使得脚本文件的调用方式与普通的可执行文件类似。

注意：**#! 告诉系统其后路径所指定的程序即是解释此脚本文件的 Shell 程序。**，当然如果不指定，则需要指明具体的调用方式，比如：`sh test.sh`，`test.sh`并没有指明具体的`shebang`,此时若直接`./test.sh`则会提示：`permission denied`。

下面列出了一些典型的 shebang 解释器指令：

1. #!/bin/sh—使用 sh，即 Bourne shell 或其它兼容 shell 执行脚本
2. #!/bin/csh—使用 csh，即 C shell 执行
3. #!/usr/bin/perl -w—使用带警告的 Perl 执行
4. #!/usr/bin/python -O—使用具有代码优化的 Python 执行
5. #!/usr/bin/php—使用 PHP 的命令行解释器执行

在许多系统上，/bin/sh 是链接到 Bash 的，而 /bin/csh 则是链接到 tcsh 的，因此设定前面的解释器实际上是运行的与之兼容的，或改进的版本。

使用 `#!/usr/bin/env 脚本解释器名称` 是一种常见的在不同平台上都能正确找到解释器的办法。比如`#!/usr/bin/env node`，因为用户的 node 可能安装在`/usr/local/bin`，也可能在`/usr/bin/`中，因此这样便去环境变量里找 node 的安装路径。

用户在 mac 上安装的包源文件一般在`/usr/local/lib/node_modules`目录里，当然如果修改了目录，可以通过`npm root -g`来查看修改的目录

**bin 目录**<br/>
bin 目录用于存放二进制程序，但还有`/usr/bin,/usr/local/bin,/opt/bin`

1. `/usr/bin`存放系统的程序
2. `/usr/local/bin`存放用户自己安装程序
3. `/opt/bin`在某些系统，用于存放第三方厂商开发的程序，所以取名 option，意为选装

**命令行**<br/>
一种编程语言是否易用，很大程度上，取决于开发命令行程序的能力。

1. 使用 js 语言，写一个脚本

```js
#! /usr/bin/env node
console.log("hello world");
```

2. 给文件添加**执行**权限

![dpr&ppi](/jsArt/assets/images/js-theory/chmod.png)

```js
// chmod命令用来变更文件或目录的权限
// 在类unix系统里，文件或目录权限的控制分别以读取，写入，执行三种权限来区分
// u(user)文件或目录的拥有者、g(group)文件或目录的所属群组、o(other)除了user和group以外的都属于这个组
// r 读权限，数字代号4；w 写权限，数字代号2；x执行或切换权限，数字代号1；不具任何权限，数字代号0
// 参考上图，第一个字符-表示普通文件，d表示目录，然后就是三组所有权
chmod 775 hello
```

经过上面的操作，就可以直接执行 hello 了，而不需要在控制台`node ./hello`。。。<br/>

3. `./hello`  
   hello world

4. 匹配解析器 path  
   如果想把 hello 前面的路径去除，可以将 hello 的路径加入环境变量 PATH。但是，另一种更好的做法，是在当前目录下新建 package.json ，写入下面的内容。可以通过 package.json 文件来建立连接。进而可以直接调用系统命令<br/>

```json
{
  "name": "hello",
  "bin": {
    "hello": "hello"
  }
}
```

5. 执行 npm link
6. 运行脚本
   现在再执行 hello ，就不用输入路径了。<br/>
   \$ hello<br/>
   hello world<br/>

**注意：**其实 chmod 只是改变文件的读、写、执行权限，更底层的属性控制是由 chattr 来改变的。

#### **拷贝并移动文件**

```bash
# 将fe-scripts文件拷贝到远程服务器某个目录下
scp -r -P 60000 /Users/finup/Desktop/fe-scripts root@10.10.xxx.xxx:/data/node-server
```

#### **npm 与 cnpm 区别**

用 cnpm 安装一些依赖的时候，有时候会有问题。。。但直接用 npm 则需要科学上网，可以尝试配置[npm-config-china][mirrorconfigchinaurl]，虽然里面很多代理依然是淘宝镜像，但还是有差别。。。刚开始配 npm，可能回慢些，这是因为缓存的问题。。。用的多了就好了

1. npm 可以自由配置镜像源
2. 两者缓存位置不同
3. cnpm 安装的库会放在 node_modules 里以下划线开头的文件夹，然后链接到应该在的位置
4. npm 有更多功能（link、audit、publish、npx 等等）
   所有 npm 包都是针对 npm 做的，所以最好使用 npm，以防在某个地方被他们的差异坑了

**注意：**其实`npm`和`cnpm`主要差别还是镜像源，因为很多包都是国外的，在国内使用就很慢，因此`cnpm`就做了一个拷贝，但是资源是拷贝过来了，但与`npm`相关的很多`api`则无法通过拷贝过来，因此`cnpm`有些局限性。。。如果通过[npm-config-china][mirrorconfigchinaurl]它来配置，则不但将镜像源改为国内，同时还可以消除`cnpm`的一些怪癖(比如软连接)，另外就是完全保留了`npm`的各个`api`。

参考：[cnode 社区说 npm][cnodesaynpmurl]、[在中国更换 npm 源][changenpmregistry]

#### **常用开启 web 服务器命令**

- python3 -m http.server
- npx http-server
- npx serve

```bash
# 还可以如下方式启动一个Node.js 静态文件服务器
npm install -g serve
# -s 参数的意思是将其架设在 Single-Page Application 模式下
# 这个模式会处理单页应用路由匹配不到，如何处理的问题(参考connect-history-api-fallback 中间件)
serve -s dist
```

#### **nvm、npx 命令**

`npx`是`npm v5.2.0` 引入的一条命令。`npx`会帮你执行依赖包里的二进制文件，引入这个命令的目的是为了提升开发者使用包内提供的命令行工具的体验。

```bash

# 以前
npm install -g create-react-app
create-react-app my-app

# 等价于
npx create-react-app my-app
```

临时安装 `create-react-app` 包，命令完成后 `create-react-app` 会删掉，不会出现在 `global` 中，下次再执行，还是会重新临时安装。

`nvm`是`node`版本管理器，当需要切换不同 node 版本时使用。

#### **常用命令**

一般情况下，命令都有很多参数或选项，**可通过：man 命令** 查看

```bash
# echo命令
# 用于输出字符串或变量的值，格式为：echo [字符串 | $变量]
$ echo hello world
=> hello world

# 变量名通常为大写，比如输出默认的shell
$ echo $SHELL
=> /bin/zsh
```

```bash
# date命令
# 用于显示及设置系统的时间或格式，格式为：date [选项] [格式]
$ date
=> 2018年11月11日 星期日 13时09分13秒 CST

# 当前具体时间
$ date "+%Y-%m-%d %H:%M:%S"
=> 2018-11-11 13:09:31

# 查看今天是当前中第几天
$ date "+%j"
=> 315
```

```bash
# reboot命令
# 用于重启系统，格式为：reboot
$ reboot

# poweroff命令
# 用于关闭系统，格式为：poweroff
$ poweroff

# ps命令，常结合管道符命令使用
# 用于查看系统中的进程状态，格式为：ps
$ ps

# top命令
# 用于动态实时监视进程活动与系统负载信息，格式为：top
# 可以看做linux中的强化版的windows任务管理器
$ top

# 管道符 |
# 把前一个命令原本要输出到屏幕上的标准正常数据当做是后一个命令的标注输入
# 如搜索一个关键字并统计行数：
grep "sbin/nologin" /etc/passwd | wc -l
```

```bash
# lsof（list open files）命令
# 用于列出当前系统打开的文件，常用查看端口占用情况如下：
$ lsof -i tcp:4000
=> ruby    66206 finup   10u  IPv4 0x1179df194c90da5b      0t0  TCP localhost:terabase (LISTEN)
```

```bash
# kill命令
# 用于终止某个指定PID的服务进程，格式为：kill [参数] [PID]，如下默认是强删
$ kill 1234

# killall命令
# 用于终止某个指定名称的服务所对应的全部进程，格式为：kill [参数] [服务名]
$ killall node
```

```bash
# wget命令
# 用于在终端下载网络文件，格式为：wget [参数] 下载地址（省略则下载到当前目录）
$ wget http://www.linuxprobe.com/docs/LinuxProbe.pdf
```

系统状态监测命令

```bash
# ifconfig命令
# 用于获取网卡配置与网络状态，格式为：ifconfig [网络设备] [参数]
# inet参数后面的ip地址，ether参数后面的网卡物理地址
# 以及rx,tx的接收数据包与发送数据包的个数及累计流量。
$ ifconfig

# uname命令
# 用于查看系统内核与系统版本等信息，格式为：uname [选项]
# 内核名称，主机名，内核发行版本，节点名，系统时间，硬件名称，硬件平台，处理器类型以及操作系统名称等。
# Darwin 是苹果公司于2000年发布的一个开放源代码操作系统，一种类Unix操作系统，
$ uname -a
=> Darwin xxx.local 16.7.0 Darwin Kernel Version 16.7.0: Thu Jun 15 17:36:27 PDT 2017; root:xnu-3789.70.16~2/RELEASE_X86_64 x86_64

# uptime命令
# 用于查看系统的负载信息，格式为：uptime
$ uptime
=> 13:50  up 22:53, 3 users, load averages: 2.28 2.69 2.46

# who命令
# 用于查看当前登入主机的用户终端信息，格式为：who [选项]
$ who

# history命令，默认显示近1000条
# 用于显示历史执行过的命令，格式为：history [选项]
$ history
```

工作目录切换命令

```bash
# pwd命令 Print Working Directory 的缩写
# 用于显示当前用户所处的工作目录，格式为：pwd [选项]
$ pwd
=> /etc

# cd命令
# 用于切换工作路径，格式为：cd [工作目录]
# 切换到家目录（其他用户家目录：~username）
$ cd ~

# ls命令
# 用于显示目录中的文件信息，格式为：ls [选项][文件]
# -a参数查看全部文件（含隐藏），-l查看文件属性，大小的等详细信息
$ ls -al
-r--------     1 finup  staff         9  6 19  2017 .CFUserTextEncoding
-rw-r--r--@    1 finup  staff     34820 11  8 17:24 .DS_Store
...
```

文件目录管理命令

```bash
# touch命令
# 用于创建空白文件或设置文件的时间，格式为：touch [选项] [文件]
$ touch

# mkdir命令
# 用于创建空白的目录，格式为：mkdir [选项] 目录，-p选项是递归嵌套
# 暂时没有直接的命令新建多层文件下的某个文件
$ mkdir -p a/b/c/d
# 还可以新建带权限的目录
$ mkdir -m 711 test2
# drwx--x--x  2 root  root 4096 Jul 18 12:54 test2

# cp命令
# 用于复制文件或目录，格式为：cp [选项] 源文件 目标文件
# 如果目标文件是目录，则会把源文件复制到该目录中
# 如果目标文件也是普通文件，则会询问是否要覆盖它
# 如果目标文件不存在，则执行正常的复制操作
$ cp

# mv命令
# 用于剪切文件或将文件重命名，格式为：mv[选项] 源文件 [目标路径|目标文件名]
$ mv A B

# rm命令
# 用于删除文件或目录，格式为：rm [选项] 文件
$ rm test.log

# file命令
# 用于查看文件的类型，格式为：file 文件名
# 查看文件的属性，linux 系统一切皆文件，因此，file 可以查看所有的文件
$ file test
=> test: directory

# tar命令
# 用于对文件进行打包压缩或解压，格式为：tar [选项] [文件]
# -c   创建压缩文件
# -x   解开压缩文件
# -t   查看压缩包内有哪些文件
# -z   用 Gzip 压缩或解压
# -j   用 bzip2 压缩或解压
# -v   显示压缩或解压的过程
# -f   目标文件名
# -p   保留原始的权限与属性
# -P   使用绝对路径来压缩
# -C   指定解压到的目录

# 把/etc 目录通 过 gzip 格式进行打包压缩，并把文件命名为 etc.tar.gz
$ tar -czvf etc.tar.gz /etc

# 打包后的压缩包文件指定解压到/root/etc 目录中
$ tar -xzvf etcctar.gz -C /root/etc

# grep命令
# 用于在文本中执行关键词搜索，并显示匹配的结果，格式为：grep [选项][文件]
$ grep

# find命令
# 用于按照指定条件来查找文件，格式为：find [查找路径] 寻找条件 操作
# 获取etc目录中所有以 host 开头的文件列表
find /etc -name "host*" -print

# npm命令
# 查看本机所有全局安装的npm包
npm ls -g --depth=0
# 还可以具体某一个,比如eslint
npm ls [eslint] -g --depth=0

```

1. [chomd 使用参考][chomduseurl]
2. [chmod write access 问题](https://www.jianshu.com/p/31744aa44824)
3. [mac 配置环境变量](https://www.jianshu.com/p/acb1f062a925)
   一般用户自己 npm 安装的包，在 usr/local/lib/node_modules 目录
   而对应的软连接放在 usr/local/bin 目录（一些二进制或可执行文件）

```bash
# chomd命令
# unix系统中对文件的修改，change mode单词前缀的组合
# 比如将/usr/local/lib目录下的权限修改为可读写可执行最高权限，
# -R表示对目前目录下的所有文件与子目录进行相同的权限变更(即以递回的方式逐个变更)
# 务必注意用户家目录为~，而电脑根目录是/
$ chmod -R 777 /usr/local/lib

# 还可以将权限指定给某个用户
$ chmod -R $(whoami) /usr/local/lib

```

有时即使按照上面操作依然会报：'checkPermissions Missing write access'错误，可以如下操作：
[npm 官方链接](https://docs.npmjs.com/resolving-eacces-permissions-errors-when-installing-packages-globally)

```bash
# 务必注意：下面方式针对的是bash，而非zsh(zsh读取的配置文件的是.zshrc)
# 第一步：在你的用户文件下新建一个文件夹，这个.npm-global 名字可以用你自己喜欢的名字替换，推荐直接使用这个名字。
mkdir ~/.npm-global
#第二步：更改node的安装连接
npm config set prefix '~/.npm-global'
#第三步：在~目录增加.profile文件并增加以下path，为的是系统能够找到可执行文件的目录
export PATH=~/.npm-global/bin:$PATH
#第四步：update profile。使其生效(注意source命令只针对当前终端有效)
source ~/.profile
```

```bash
# 2，查找文件
locate xxx     （会自动生成一个本地数据库）

# 3，修改远程主机密码或加密方式
# 1，登录主机
# 2，修改配置文件（/etc/shadowsocks-libev/config.json）
# 3，重启服务（service shadowsocks  reatsrt）
# 4，查看状态（service shadowsocks  status ）
# 服务启动与重启还可以用systemctl start shadowsocks
# 当服务成功启动后，可使用如下命令测试：
curl -x http://localhost:1087 ip.sb
curl -x socks5://localhost:1080 ip.sb
# 如果成功，则返回远程服务器的ip地址

# 4，删除某个文件下，某个类型所有的文件
# 删除所有当前文件夹下以CR2后缀的文件
find ./ -name "*.CR2" | xargs rm -rf

# 删除仓库所有的DS_Store文件
find . -name .DS_Store -print0 | xargs -0 git rm -f --ignore-unmatch

# 删除文件夹及文件下所有的文件（慎用）
rm -rf

# 5，开启本地文件服务器，对外开发，在对应文件夹下运行，就开发对应目录的文件
python3 -m http.server

# 6，查看一些网络连接情况，比如请求头，请求行，请求体，响应体等 ，其实curl是文件传输工具
curl -v carplatform.finupgroup.com

# 7，Linux which命令用于查找文件。
# which指令会在环境变量$PATH设置的目录里查找符合条件的文件。
which gst
# gst: aliased to git status

which zsh
=> /bin/zsh  #zsh可执行程序的绝对路径

# 8，查看环境变量映射的文件绝对路径
ll $(which npm)
# //       /usr/local/bin/npm -> ../lib/node_modules/npm/bin/npm-cli.js
# 用户安装到电脑里的包，基本都安装在usr/local/lib这个目录下

# 9，查看某个命令的细节（此处是less，还可以是其他命令）
less $(which npm)

# 10，查看仓库所有镜像
docker images

# 11，删除镜像仓库里的缓存镜像
docker rmi -f $(docker images -q)

# 12，npx 自动查找当前依赖包中的可执行文件，如果找不到，就去PATH里找，如果依然找不到，就会帮你安装
npx github:piuccio/cowsay hello
# 再比如开启一个http-server服务，上面是用python3开启的，这里可以直接：
npx http-server   还可以 npx serve
# 还可以指定端口
npx serve -p 5001

# 13，npm root -g可以查看全局安装的包目录在哪

# 14，压缩当前目录某个文件夹
tar -zcvf  target.tar.gz  source        source是源文件目录，target是目标文件目录

# 15，root权限和普通账号权限问题，有时候全局安装一些包的时候，需要root权限，而/usr/local目录所有者root，因此全局安装某些包的时候需要在普通用户与超级用户之间来回切换。。。比如用sudo
# 其实可以修改目录的所有者，从而拥有和root权限相同的效果，如下即可把/usr/local的所有者变为当前用户了，就再也不用使用sudo了：
# 改变其他目录的所有者也是同样道理
sudo chown -R $(whoami) /usr/local
查看当前那个账户：echo $(whoami)

# 16，压力测试
ab -n 1000 -c 100 http://official.car.beta/

# 17， “您不能使用以点“.”开头的名称，因为这些名称已被系统预留。请选取其他名称。”。。。在指定文件夹下，command+shift+.   可以显示隐藏文件，然后再修改

18，查看某个端口对应的进程：
# 查看tcp连接
lsof -i tcp:8081
# 查看3000端口
lsof -i :3000
# 杀掉对应PID的进程 ：
kill -9 PID

# 19，复制文件操作
# 源地址dir1，目标地址dir2，复制dir1下所有文件到dir2中
cp -r dir1 dir2
# 如果dir2目录已存在，则需要使用
cp -r dir1/. dir2

# 20，后台运行程序
# 在终端先启动node服务，启动后放后台，执行echo 即输出1
node & echo 1
# 在终端启动node服务，服务因为一直运行，所以echo不会执，在输入.exit退出node服务，则执行echo 1
node && echo 1

# 21，ifconfig配置和显示linux内核中网络接口的网络参数

# 22,常用快捷键
# 使当前行向上或者向下移动
ctrl-cmd-up, ctrl-cmd-down
# 复制当前行到下一行
cmd-shift-D
ctrl-shift-K 删除当前行
cmd-backspace 删除到当前行开始
cmd-fn-backspace 删除到当前行结束

# 23，PM2是node进程管理工具，可以利用它来简化很多node应用管理的繁琐任务，
#     如性能监控、自动重启、负载均衡等，而且使用非常简单。
pm2 list
pm2 delete 0

# 24，定制终端欢迎页面
# 快捷键control+space唤出Spotlight，搜索terminal打开终端
cd /etc
#  输入密码后进入修改页面
sudo pico motd
# 输入自定义图案或文字

# 输出重定向
# 命令 > 文件  将标准输出重定向到一个文件中（清空原有文件的数据）
# 命令 2> 文件  将错误输出重定向到一个文件中（清空原有文件的数据）
# 命令 >> 文件  将标准输出重定向到一个文件中（追加到原有内容的后面）
# 命令 2>> 文件  将错误输出重定向到一个文件中（追加到原有内容的后面）
# 将man bash命令原本要输出到屏幕上的信息写入到文件raedme.txt
man bash > readme.txt

# 输入重定向
# 把readme.txt文件导入给wc -l 命令统计一下行数
wc -l < readme.txt
# 等价于管道符
cat readme.txt | wc -l

# 命令 < 文件1 > 文件2   将文件1作为命令的标准输入并将标准输出到文件2
```

#### **vi 编辑器 常用操作**

[vi 常用操作][vicommonuseurl]  
三种模式：

1. **普通模式**
   由 Shell 进入 vi 编辑器时，首先进入普通模式。在普通模式下，从键盘输入任何字符都被当作命令来解释。普通模式下没有任何提示符，输入命令后立即执行，不需要回车，而且输入的字符不会在屏幕上显示出来。

   普通模式下可以执行命令、保存文件、移动光标、粘贴复制等。

2. **编辑模式**
   编辑模式主要用于文本的编辑。该模式下用户输入的任何字符都被作为文件的内容保存起来，并在屏幕上显示出来。

3. **命令模式**
   命令模式下，用户可以对文件进行一些高级处理。尽管普通模式下的命令可以完成很多功能，但要执行一些如字符串查找、替换、显示行号等操作还是必须要进入命令模式。

   注意：有些教程中称有两种工作模式，是把命令模式合并到普通模式。

4. **模式切换**

- 在普通模式下输入 i(插入)、c(修改)、o(另起一行) 命令时进入编辑模式；按 esc 键退回到普通模式。
- 在普通模式下输入冒号(:)可以进入命令模式。输入完命令按回车，命令执行完后会自动退回普通模式

5. **退出 vi 编辑器**

- q 如果文件未被修改，会直接退回到 Shell；否则提示保存文件
- q! 强行退出，不保存修改内容(q 就是退出的意思)
- wq w 命令保存文件，q 命令退出 vi，合起来就是保存并退出。(w 其实就是 write 的意思)
- ZZ 保存并退出，相当于 wq，但是更加方便。

#### unix&linux&windows

##### 历史故事

上世纪六十年代，多数计算机都采用批处理命令。为了研发一个多用途，多用户的操作系统。美国电话及电报公司`（American Telephone and Telegraph Inc.；AT&T）`、通用电器公司（`General Electrics；G.E.）`及麻省理工学院`（Massachusetts Institute of Technology；MIT）`联合起来研发。整个项目研发出来的操作系统被称之为`MULTICS`。但 MULTICS 项目开始迷失，目标过于庞大，功能过于复杂，研发的人们越来越不明白这个项目将会如何走下去。最终隶属 AT&T 公司的贝尔实验室（Bell Labs）退出了这个项目。

**注意：**电话就是贝尔实验室里诞生的。

退出后，由于无法使用之前的`MULTICS`系统，当时贝尔实验室有个叫`Ken Thompson`的人，他负责为为 MULTICS 这个操作系统写游戏了个叫“Space Travel”的游戏。为了让这个游戏能继续下去，他不得不重新编写一个操作系统。

这个操作系统当时被`Ken Thompson`的同事嘲笑说，功能单一，开玩笑的说干脆叫`Unics`(unics 在英文里表示单一，与 mult 相反)算了，而`Ken Thompson`的初衷也是为了游戏，而不是操作系统，因此也就接收了这个名字。

但另一个同事`Dennis Ritchie`对这个系统(`Unics`)很感兴趣，但这个系统有个缺点就是可移植性太差，无法匹配多个机型。。。因此 Dennis Ritchie 在 BCPL(是一种计算机程序设计语言，源自更早的 CPL 语言，1966 年由剑桥大学的马丁·理察德（Martin Richards）所发展出来的)基础上，开发了一种新的高级语言将 Unics 重新写了一遍，并命名为 UNIX，而今日流行的 C 语言即是参考 BCPL 所设计。

而`Ken Thompson`在休假的那一年选择去伯克利（Berkeley）进行教学，也难怪欧美的教育科技那么发达，总有黑客将知识和技术进行传承。由于当时 AT&T 被美国反垄断制裁，Bell 实验室不能销售 Unix。只能无偿提供大家学习研究。正是因为这样开放环境，使得 Unxi 的功能和特性被不断的丰富。在 Berkeley，有一个专门研究 UNIX 小组，他们为 UNIX 提供了很多新特性，例如著名的 TCP/IP 协议。并完成了 BSD(伯克利软件包（英语：Berkeley Software Distribution，缩写：BSD；也被称为伯克利 Unix 或 Berkeley Unix）是一个派生自 Unix（类 Unix）的操作系统，) 版本。很快，就有公司看到了 BSD 的商机，分分购买 BSD 进行商用。

这个时候，AT&T 公司对其他机构拿着 Unix 赚钱自己却一无所获很不爽。那是一个 AT&T 妄图私有化的 Unix 的时代。为了私有化 Unix，1986 年 IEEE 指定了一个委员会制定了一个一个开放作业系统的标准,称为 POSIX (Portable Operating Systems Interface)。并和 BSD 进行法律官司，最终赢得了官司并取得了 unix 注册商标。此时 BSD 的拥护者自喻为冷酷无情的公司帝国的反抗军。独立的 Bell 实验室就可以单独销售 Unix，当时价格昂贵。也就在这个时候，人们被昂贵的 Unix 吓怕了，使用的人数骤减。与此同时，Berkeley BSD 小组的 Bill Joy 开始创办了一家公司，也就是后来全球知名的 SUN 公司。就销售量来说，AT&T/UNIX 始终赶不上 BSD/Sun。并且 Sun 生产的小型工作站，风靡整个市场，很快就将 DEC(迪吉多（英语：Digital Equipment Corporation，简称“DEC”）是成立于 1957 年的一家美国老牌电脑公司，发明了 Alpha 微处理器，后于 1998 年被康柏电脑收购。) 击败，并且让 DEC 退出了历史舞台。

参考链接：[操作系统 Unix、Windows、Mac OS、Linux 的故事 科普篇](https://blog.csdn.net/zhanghow/article/details/53542397)

GNU 是一个类 Unix 操作系统。它是由多个应用程序、系统库、开发工具乃至游戏构成的程序集合。GNU 的开发始于 1984 年 1 月，称为 GNU 工程。GNU 的许多程序在 GNU 工程下发布；我们称之为 GNU 软件包。

“GNU” 这个名字是 “GNU's Not Unix” 的递归首字母缩写词
类 Unix 操作系统中用于资源分配和硬件管理的程序称为 “内核”。GNU 所用的典型内核是 Linux。该组合叫做 GNU/Linux 操作系统。GNU/Linux 为几百万用户所使用，然而许多人 错误地称之为 “Linux”。GNU 自己的内核，The Hurd，开始于 1990 年（早于 Linux）。志愿者们仍在继续开发 Hurd，因为它是一个有趣的技术项目。

Linux 是一个内核，但不能仅使用内核，内核作为整个系统的一部分才有用。Linux 内核是和 GNU 操作系统结合在一起使用。可用的自由软件加在一起就组成过来一个完整的系统，而 GNU 宣言就是开发一个类似 Unix 的自由系统为目标。

大多数自由软件的工程都是为了特定的工作开发特定的程序，比如说：Linus Torvalds 编写类似 Unix 的内核（Linux）,Donald Knuth 编写一个文本格式化工具(TeX); Bob Scheifler 开发一个窗口系统(X Window System)。

GNU 工程本意是开发系统，并不是开发某个软件包的工程，但却做了很多这样的软件包，比如 开发 C 编译器的工程，GNU 也不是一个文本编辑器的工程，但也做了 Emacs，永远牢记：GNU 工程的目标是开发一个完全自由的类似 Unix 的系统：GNU

除了 GNU，还有一个独立进行的工程开发了一个自由的类似 Unix 的操作系统。这个系统被称为 BSD，它是由 UC Berkeley 开发的。 在 GNU 工程的鼓舞下，BSD 的开发者开始进行他们自己的自由软件的开发工作，并时常受到 GNU 人士的鼓励，但是他们的实际工作与 GNU 差别不大。今天 BSD 系统采用一些 GNU 软件，就象不同版本的 GNU 系统也采用 BSD 的软件一样。总的说来，它们是两套独立开发的不同的系统。今天一个免费的操作系统几乎都是采用 GNU 或 BSD 系统的一个派生版本。

osx 是 FreeBSD 修改版，macOS（2012 年前称 Mac OS X，2012 年-2016 年称 OS X，2016 年起称 macOS）是苹果公司推出的一系列图形用户界面操作系统，为麦金塔电脑专属，

##### 查看 linux 发行版及版本号

Linux 发行版（英语：Linux distribution，也被叫做 GNU/Linux 发行版），为一般用户预先集成好的 Linux 操作系统及各种应用软件。现在有超过 300 个 Linux 发行版。。。

这些发行版可以分为商业发行版，比如 Ubuntu（Canonical 公司）、Fedora（Red Hat）、openSUSE（Novell）和 Mandriva Linux；和社区发行版，它们由自由软件社区提供支持，如 Debian 和 Gentoo；也有发行版既不是商业发行版也不是社区发行版，如 Slackware。

发行版通常被分割成软件包。每个软件包都包含了一个特定的软件或服务。比如说处理 PNG 图像格式的库，一套字体，或者一个浏览器。

软件包通常是已编译的机器码，并且由软件包管理器安装和卸载。每一个软件包都包含为包管理器提供的元数据，比如描述和版本，以及"依赖"。包管理器能够使用这些元数据提供搜索功能、将软件包自动更新到最新版本，以及自动解决依赖。

**几个主流的 linux 发行版**：

1. Debian

Debian 拥有大量的软件包，因其定期测试、更新和坚如磐石在稳定性而享有盛誉，这种稳定性使程序员可以放心地展开开发工作。但请记住，Debian 只推荐给有 Linux 工作经验的程序员。 如果你是初学者，推荐使用 Ubuntu LTS 版本或其它稳定的 Linux 发行版。apt 软件包管理机制可以让用户快速建立起来高效的操作系统。稳定性也是出名的。

1. CentOS

RHEL 在 Linux 桌面世界中享有与 Ubuntu 相同的企业竞争优势，CentOS 则是在不花费任何费用的情况下获得 RHEL 好处的方法。换句话说，CentOS 就是社区支持的 RHEL。由于 CentOS 与 RHEL 及其存储库中的二进制包都是久经考验的软件，因此您可以将其用作生产系统或服务器进行使用。

1. Ubuntu

Canonical 的 Ubuntu 基于 Debian 架构，在稳定性和新功能方向都得到了很好的平衡。如果您运行的硬件功能有限，请尝试使用 Ubuntu MATE、Xubuntu 或 Lubuntu 等对于功能强大的个人电脑和笔记本电脑，运行 GNOME 桌面的旗舰 Ubuntu 是完美的。 随着 Snap 的引入，安装应用程序变得更加舒适。 它还拥有一个蓬勃发展的用户社区和论坛，你可以在其中找到任何问题的答案。总的来说，Ubuntu 是一个功能非常强大的 Linux 发行版，可以让您多任务并高效地完成工作。

1.

**最常见的软件包格式**包括：Debian 的 DEB，以及 Fedora (Red Hat) 的 RPM 等。

```bash
# 查看linux内核版本
# 方法一
cat /proc/version
# Linux version 4.13.1-041301-generic (kernel@tangerine) (gcc version 7.2.0 (Ubuntu 7.2.0-3ubuntu1)) #201709100232 SMP Sun Sep 10 06:33:36 UTC 2017

# 方法二
uname -a
# Linux djch 4.13.1-041301-generic #201709100232 SMP Sun Sep 10 06:33:36 UTC 2017 x86_64 GNU/Linux

# 查看linux系统版本
# 方法一(适用于所有linux发行版，如Redhat、SuSE、Debian…等)
lsb_release -a
# No LSB modules are available.
# Distributor ID: Debian
# Description: Debian GNU/Linux 8.7 (jessie)
# Release: 8.7
# Codename: jessie

# 方法二(只适合Redhat系的Linux)
cat /etc/redhat-release
# 方法三
cat /etc/issue
# Debian GNU/Linux 8 \n \l
```

##### 文件系统

linux 是一个多用户，多任务的操作系统，具有很好的稳定性和安全性，在幕后保障 linux 系统安全的则是一些列复杂的配置工作。

文件的所有者，所属组以及其他人可对文件进行读(r)，写(w)，执行（x）等操作，以及如何在 linux 系统中添加，删除，修改用户账户信息。我们还可以使用 SUID,SGID 和 SBIT 特殊权限更加灵活地设置系统权限功能，来弥补对文件设置一般操作权限时所带来的不足。隐藏权限能够给系统增加一层隐形的防护层，让黑客最多只能查看关键日志信息，而不能进行修改或删除。文件的访问控制列表可以进一步让单一用户，用户组对单一文件或目录进行特殊的权限设置，让文件具有能够满足工作需求的最小权限。如果使用 su 命令与 sudo 服务让普通用户具备管理员的权限，不仅可以满足日常的工作需求，还可以确保系统的安全性

设计 linux 系统的初衷之一是为了满足多个用户同时工作的需求，因此 linux 系统必须具备良好的安全性。

root 管理员就是存在所有 unix 系统中的超级用户，它拥有最高的系统所有权，能够管理系统的各项功能，虽然以 root 管理员身份工作时不会受到系统的限制，但俗称能力越大，责任越大，因此一旦使用 root 管理员权限执行了错误的命令可能会直接毁掉整个系统

linux 系统的管理员之所以是 root，并不是因为它的名字叫 root，而是因为该用户的身份号码即 UID（User IDentification）的数值为 0，在 linux 系统中，UID 相当于我们的身份证号一样具有唯一性。

管理员 UID 为 0，系统的管理员用户，系统用户 UID 为 1-999,linux 系统为了避免因某个服务程序出现漏洞而被黑客攻击整个服务器，默认服务程序会有独立的系统用户负责运行，进而有效控制被破坏范围。

普通用户 UID 从 1000 开始：是由管理员创建的用于日常工作的用户。UID 是不能冲突的，而且管理员创建的普通用户的 UID 默认是从 1000 开始的，即使前面有闲置的号码。

为了方便管理属于同一组的用户，linux 系统中还引入了用户组的概念，通过使用用户组号码（GID，Group IDentification）,我们可以把多个用户加入到同一个组中，从而方便为组中的用户同一规划权限或执行任务，假设有一个公司中有多个部门，每个部门有很多员工，如果想让员工访问本部门内的资源，则可以针对部门而非具体的员工来设置权限。

另外在 linux 中，创建每个用户时，将自动创建一个与其同名的基本用户组，而且这个基本用户组只有该用户一个人，如果该用户以后被纳入其他用户组，则这个其他用户组称之为扩展用户组，一个用户只有一个基本用户组，但可以有多个扩展用户组。

**创建用户**：

useradd 命令用于创建新的用户 格式：`useradd [选项] 用户名`，使用该命令创建的账户，默认的用户家目录放在/home 目录中。

在 mac 系统下，不是使用 useradd，而是使用 dscl 命令，command not found 一般是三个原因，一个是命令不属于该系统，一个是环境变量没设置，一个是没有安装

在 linux 下创建一个用户目录，不但可以指定家目录的路径，用户的 UID 和 shell 解释器，还有很多其他命令

groupadd 命令用于创建用户组，格式为 groupadd [选项] 群组名，为了能够更加高效的指派系统中各个用户的权限，在工作红常常把几个用户加入到同一个组里面，这样便可以针对一类用户统一安排权限。

usermod 命令用于修改用户的属性，格式为 usermod [选项] 用户名，在 linux 中，一切皆文件，因此在系统中创建用户也就是修改配置文件的过程，用户信息保存在/etc/passwd 文件中,可以用编辑器直接修改文件，还可以通过命令 usermod 命令修改已经创建的用户信息。诸如用户的 UID,基本/扩展用户组，默认终端等。

passwd 命令，用于修改用户密码，过期时间，认证信息等，格式为 passwd [选项] 用户名
普通用户只能使用 passwd 命令修改自身的系统密码，而 root 管理员则有权修改其他所有人的密码。更酷的是，root 管理在 linux 系统中修改自己或他人的密码时不需要验证旧密码

userdel 命令用于删除用户，格式为 userdel [选项] 用户名

**文件归属**:  
尽管在 linux 系统中一切都是文件，但是每个文件的类型不尽相同，因此 linux 系统使用了不同的字符来加以区分（其实就是文件最前面的标识如：`drwxr-xr-x，-rw-r--r--`），常见的字符如下表示：

- -：普通文件
- d: 目录文件
- | : 链接文件

**文件权限与数字表示**:

于 linux 中的文件，每个文件的所属者，所有组，及其他人对文件拥有的可读，可写，可执行等权限，对于目录而言，可读表示能够读取目录内的文件列表，可写表示能够在目录内新增，删除，重命名文件，可执行则表示能够进入该目录。

![文件权限与数字表示](/jsArt/assets/images/server/filePremission.png)

文件权限的数字法表示基于字符表示 rwx 的权限计算而来，其目的是简化权限的表示

在复杂多变的生产环境中，单纯设置文件的 rwx 权限无法满足我们队安全和灵活性的需求，因此有了 SUID，SGID 和 SBIT 的特殊权限位。这是一种对文件权限进行设置的特殊功能，可以与一般权限同时使用，以弥补一般权限不能实现的功能。

SUID 是一种对二级制程序进行设置的特殊权限，可以让二进制程序的执行者临时拥有属主的权限（仅对拥有执行权限的二进制程序有效），很像古装剧中见到的手持尚方宝剑的钦差大臣，他手持尚方宝剑代表的是皇上的权威，因此可以惩戒贪官，但这并不意味这它永久成为皇上。因此这只是一种有条件的，临时的特殊权限授权方法。

SGID 主要实现如下两种功能：
1，让执行者临时拥有属组的权限（对拥有执行权限的二进制程序进行设置）
2，在某个目录中创建的文件自动继承该目录的用户组(只可以对目录进行设置)

- chmod 命令用来设置文件或目录的权限
- chown 命令用来设置文件或目录的所有者和所有组

![linux里的文件属性](/jsArt/assets/images/server/linuxFileSys.png)

在 Linux 系统中，用户是按组分类的，一个用户属于一个或多个组。文件所有者以外的用户又可以分为文件所有者的同组用户和其他用户。因此，Linux 系统按文件所有者、文件所有者同组用户和其他用户来规定了不同的文件访问权限。

```bash
[root@www /]# ls -l
total 64
drwxr-xr-x 2 root  root  4096 Feb 15 14:46 cron
drwxr-xr-x 3 mysql mysql 4096 Apr 21  2014 mysql

# 在以上实例中，mysql 文件是一个目录文件，属主和属组都为 mysql，
# 属主有可读、可写、可执行的权限；与属主同组的其他用户有可读和可执行的权限；
# 其他用户也有可读和可执行的权限。
# 对于 root 用户来说，一般情况下，文件的权限对其不起作用。

# 更改文件属主，也可以更改文件属组，-R可选，表示递归
chown [–R] 属主名 文件名
chown [-R] 属主名：属组名 文件名

# 如将cron及子目录的拥有者改为bin这个账号
chmod -R bin cron
# 如将mysql的拥有者和群组改为root：
chmod -R root:root mysql
```

SBIT 现在大学的很多老师都要求学生将作业上传到服务器的特定共享目录中，但总是有几个破坏分子喜欢删除其他同学的作业。这时就要设置 SBIT（sticky bit）特殊权限位了（也可以称之为特殊限位之粘滞位），SBIT 特殊权限位可确保用户只能删除自己的文件，而不能删除其他用户的文件
在 RHEL 7 系统中的/tmp 作为一个共享文件的目录，默认已经设置了 SBIT 特殊权限位，因此除非是该目录的所有者，否则无法删除这里面的文件。其实文件能否被删除不取决于自身的权限，而是看其所在目录是否有写入权限。

linux 系统中除了具备一般权限和特殊权限之外，还有一种隐藏权限，即被隐藏起来的权限，默认情况下不能直接被用户察觉，有用户曾经在生产环境和 RHCE 考试题目中碰到明明权限充足但却无法删除某个文件的情况，或者仅能在日志文件中追加内容而不能修改和删除内容。这一定程度上阻止了篡改系统日志的图谋

**chattr 命令用于设置文件的隐藏属性**，格式为 chattr [参数] 文件 ，如果想要把某个隐藏功能添加到文件上，则需要在命令后面追加`+`参数，如果想要隐藏功能则需要追加`-`参数，对于 chattr 添加上的隐藏属性，可以用命令 lsattr 命令来查看，普通的 ls 则无法看出端倪。

**su 命令和 sudo 命令**:  
su 命令可以解决用户身份的需求，使得当前用户在不退出登录的情况下，顺畅地切换到其他用户，比如从 root 切换至普通用户。

`su - 用户名`, 这里添加 - 的作用是：完全切换，即把环境变量信息也变成新用户的相应信息，而不是保留原始的信息。

切换到 root 账户时需要密码，这时容易将密码暴露给黑客，因此这并不是最安全的方案，sudo 命令就是解决这个问题的，指把特定命令的执行权限赋予给指定用户，这样既可保证普通用户能够完成特定的工作，也可以避免泄露 root 管理员密码。我们要做的就是合理配置 sudo 服务，以便兼顾系统的安全性和用户的便捷性，sudo 服务的配置原则也很简单，在保证普通用户完成相应工作的前提下，尽可能少地赋予额外的权限。

sudo 命令用于给普通用户提供额外的权限完成原本 root 管理员才能完成的任务。linux 一切皆文件，sudo 服务因此也是文件，/etc/sudoers 但是这个文件只能 root 权限可以修改，同时也暴露一个 api 供用户修改参数，即 visudo，但仍然是 root 才有权限。
可以用 whereis 命令来查看指令的环境变量。

**目录结构**:  
在 linux 系统中，目录，字符设备，块设备，套接字，打印机等都被抽象成了文件，即一切皆文件。既然与我们接触的都是文件，那就应该想办法找到他们，在 windows 操作系统中，想要找到一个文件，要依次进入该文件所在的磁盘分区及目录等。但在 linux 中并不存在盘符，linux 系统中的一切文件都是从根/开始，并按照文件系统层次化标准 fhs 采用树形结构存放文件，以及定义了常见目录的用途。另外 linux 系统中的文件和目录名是严格区分大小写的。

![dpr&ppi](/jsArt/assets/images/server/linuxMulu.png)

前文提到的 FHS 是根据以往无数 Linux 系统用户和开发者的经验而总结出来的，是用户在 Linux 系统中存储文件时需要遵守的规则，用于指导我们应该把文件保存到什么位置，以及告诉用户应该在何处找到所需的文件。但是，FHS 对于用户来讲只能算是一种道德上的约束，有些用户就是懒得遵守，依然会把文件到处乱放，有些甚至从来没有听说过它。

在 linux 系统常见的目录名称以及相应内容:

- /boot 启动 linux 时的核心文件，包括一些连接文件及镜像文件等
- /bin Binary 的缩写，存放单用户模式下还可以操作的命令
- /dev Device 的缩写，存放的是 Linux 的外部设备，在 Linux 中访问设备的方式和访问文件的方式是相同的。
- /etc 存放所有的系统管理所需要的配置文件和子目录
- /home 用户主目录，在 Linux 中，每个用户都有一个自己的目录，一般该目录名是以用户的账号命名的。
- /lib 这个目录里存放着系统最基本的动态连接共享库，其作用类似于 Windows 里的 DLL 文件。几乎所有的应用程序都需要用到这些共享库，以及/bin 与/sbin 下面的命令要调用的函数
- /lost+found 这个目录一般情况下是空的，当系统非法关机后，这里就存放了一些丢失的文件。
- /media linux 系统会自动识别一些设备，例如 U 盘、光驱等等，当识别后，linux 会把识别的设备挂载到这个目录下。
- /opt 这是给主机额外安装软件所摆放的目录。比如你安装一个 ORACLE 数据库则就可以放到这个目录下。默认是空的。
- /root 该目录为系统管理员，也称作超级权限者的用户主目录。
- /sbin s 就是 Super User 的意思，这里存放的是系统管理员使用的系统管理程序。
- /srv 该目录存放一些服务启动之后需要提取的数据。
- /tmp 这个目录是用来存放一些临时文件的。
- /usr 这是一个非常重要的目录，用户的很多应用程序和文件都放在这个目录下，类似于 windows 下的 program files 目录。
- /usr/bin 系统用户使用的应用程序。
- /usr/sbin 超级用户使用的比较高级的管理程序和系统守护程序。
- /usr/src 内核源代码默认的放置目录。
- /var 这个目录中存放着在不断扩充着的东西，我们习惯将那些经常被修改的目录放在这个目录下。包括各种日志文件。
- /run 是一个临时文件系统，存储系统启动以来的信息。当系统重启时，这个目录下的文件应该被删掉或清除。如果你的系统上有 /var/run 目录，应该让它指向 run。
- /proc 这个目录是一个虚拟的目录，它是系统内存的映射，我们可以通过直接访问这个目录来获取系统信息。
  这个目录的内容不在硬盘上而是在内存里，我们也可以直接修改里面的某些文件，比如可以通过下面的命令来屏蔽主机的 ping 命令，使别人无法 ping 你的机器：
- 绝对路径是从根目录/开始写起的文件或目录名称

`/bin, /sbin, /usr/bin, /usr/sbin:` 这是系统预设的执行文件的放置目录，比如 ls 就是在/bin/ls 目录下的。

值得提出的是，/bin, /usr/bin 是给系统用户使用的指令（除 root 外的通用户），而/sbin, /usr/sbin 则是给 root 使用的指令。

/var： 这是一个非常重要的目录，系统上跑了很多程序，那么每个程序都会有相应的日志产生，而这些日志就被记录到这个目录下，具体在/var/log 目录下，另外 mail 的预设放置也是在这里。

**注意**：在 Linux 或 Unix 操作系统中，所有的文件和目录都被组织成以一个根节点开始的倒置的树状结构。文件系统的最顶层是由根目录开始的，系统使用 / 来表示根目录。在根目录之下的既可以是目录，也可以是文件，而每一个目录中又可以包含子目录文件。如此反复就可以构成一个庞大的文件系统。

如果一个目录或文件名以一个点 . 开始，表示这个目录或文件是一个隐藏目录或文件(如：.bashrc)。即以默认方式查找时，不显示该目录或文件。

拿到一块新的硬盘后，需要先分区，然后再格式化文件系统，最后才能挂载并正常使用。格式化都发生了什么？

我们在习惯了 windows 系统后总觉得一切都是理所当然的，平时把 u 盘插入到电脑后也没有考虑过 windows 系统做了哪些事情，才使得我们可以访问这个 u 盘的。接下来学习一下 linux 系统中挂载和卸载设备的的方法。

当用户需要使用硬盘设备或分区中的数据时，需要先将其与一个已存在的目录文件进行关联，而这个关联动作就是挂载，mount 命令用于挂载文件系统，格式为：`mount 文件系统 挂载目录` ，挂载是在使用硬件设备前所执行的最后一步操作。只需要使用 mount 命令把硬盘设备或分区与一个目录文件进行关联，然后就能在这个目录中看到硬件设备中的数据了。

例如把设备/dev/sdb2 挂载到/backup 目录，系统会自动判断要挂载文件的类型，mount /dev/sdb2 /backup，但上面的命令是一次性的，如果想永久写入，需要修改配置文件。

如果硬件存储设备没有进行格式化，则 linux 系统无法得知怎么在其上写入数据，因此在对存储设备进行分区后还需进行格式化操作。

**内存及软硬连接**：  
linux 系统的设计初衷之一是让许多人使用并执行各自的任务，从而成为多用户，多任务的操作系统，但是硬件资源是固定且有限的，如果一直不停的存放文件，硬盘空间总有一天会被占满，针对这个情况，root 管理员就需要使用磁盘容量配额服务来限制某位用户或某个用户组针对特定文件夹可以使用的最大硬盘空间或最大文件个数，从而限制用户的硬盘可用容量或所能创建的最大文件个数，quota 命令还有软限制和硬限制的功能。

- 软限制：当达到软限制时会提示用户，但仍允许用户在限定的额度内使用
- 硬限制：当达到应限制时会提示用户，且强制终止用户的操作。

在 windows 里面，快捷方式就是指向原始文件的一个链接文件，可以让用户从不同的位置来访问原始文件，原始文件一旦删除或剪切到其他地方，会导致链接文件失效。在 linux 系统中存在软链接和硬链接两种

- 软链接（也称为符号链接[symbolic link]）：仅仅包含所链接文件的路径名，因此能链接目录文件，也可以跨越文件系统进行链接。但是，当原始文件被删除后，链接文件也将失效，从这一点上来说与 Windows 系统中的“快捷方式”具有一样的性质。

`ln 命令`用于创建链接文件，格式为`ln [选项] 目标`。在使用 ln 命令时，是否添加-s 参数，将创建出性质不同的两种“快捷方式”。

- -s 创建符号连接，如果不带-s，则默认是硬链接
- -f 强制创建文件或目录的链接
- -i 覆盖前先询问
- -v 显示创建链接的过程

##### 服务、进程、包、软件管理

RPM（红帽软件包管理器）公布之前，要想在 linux 系统中安装软件只能采用源码包的方式安装，早期在 linux 系统中安装程序是一件非常困难，耗费耐心的事情，而且大多数的服务程序仅仅提供源码，需要运维人员具备丰富知识，高超的技能，甚至良好的耐心。RPM 机制就是为解决这些问题而设计的，RPM 有点像 windows 系统中的控制面板，会建立统一的数据库文件，详细记录软件信息并能够自动分析依赖关系。

Yum 软件仓库，虽然 RPM 能够帮助用户查询软件相关的依赖关系，但问题还是要运维人员自己来解决，而有些大型软件可能与数十个程序有依赖关系，因此安装时就会很不方便。Yum 软件仓库便是为了进一步降低软件安装难度和复杂度而设计的技术。Yum 软件仓库可以根据用户的要求分析出所需软件包以及复杂的依赖关系，然后自动从服务器下载软件并安装到系统。其实就相当与 npm

**Systemd 初始化进程**：  
linux 操作系统的开机过程是这样的，即从 BIOS 开始，然后进入 Boot Loader，再加载系统内核，然后内核初始化，最后启动初始化进程。初始化进程作为 linux 系统的第一个进程，它需要完成 linux 系统中相关的初始化工作，为用户提供核实的工作环境。systemd 初始化进程采用了并发启动机制，开机速度得到了不小的提升，虽然 systemd 初始化进程服务具有很多新特性和优势，。

通常来讲，计算机硬件是由运算器，控制器，存储器，输入/输出设备等共同组成的，而让各种硬件设备各司其职且又能协同运行的东西就是系统内核，linux 系统的内核负责完成硬件资源的分配，调度等管理任务。因此系统内核对计算机很重要，但一般不直接修改内核配置，而是通过内核暴露的接口进行调用。
linux 系统也有自己的图形化界面，但图形化界面会更加消耗系统资源，因此，运维更多的时候是直接通过命令行模式远程连接。shell 就是这样的一个命令行工具，shell（也叫终端或壳）充当的是人与内核之间的翻译官，用户把一些命令告诉终端，他就会调用相应的程序服务区完成某些工作。

##### FTP 协议

一般来讲，人们将计算机联网的首要目的就是获取资料，而文件传输是一种非常重要的获取资料的方式，不同的计算机，可能会装 windows,linux,unix,mac 等不同的系统，为了能够在如此复杂多样的设备之间解决文件传输问题，文件传输协议 FTP 应运而生。

FTP 是一种在互联网中进行文件传输的协议，基于客户端/服务器模式，默认使用 20，21 号端口，其中端口 20(数据端口)用于进行数据传输，端口 21（命令端口）用于接收客户端发出的相关 FTP 命令与参数。FTP 服务器普遍部署于内网中，具有容易搭建，方便管理对的特点，而且有些 FTP 客户端工具还可以支持文件的多点下载以及断点续传技术。

ftp 服务器是按照 ftp 协议在互联网上提供文件存储和访问服务的主机，ftp 客户端则是向服务器发送链接请求，以建立数据传输链路的主机，ftp 协议有两种工作模式

- 主动模式：ftp 服务器主动向客户端发起连接请求
- 被动模式：ftp 服务器等待客户端发起连接请求，这是默认工作模式

##### ssh 登录远程

ssh（secure shell）是一种能够以安全的方式提供远程登录的协议，也是目前远程管理 linux 系统的首选方式，之前一般使用 FTP 或 Telnet 来进行远程登录，但是因为他们以明文的形式在网络中传输账户密码和数据信息，因此很不安全，很容易遭受中间人攻击，这轻则篡改传输的数据信息，重则直接抓取服务器的账户密码。

想要使用 ssh 协议来远程管理 linux 系统，则需要部署配置 sshd 服务程序，sshd 是基于 ssh 协议开发的一款远程管理服务程序，不仅使用起来方便快捷，而且能够提供安全验证的方法：

1. 基于口令的验证-用账户和密码来验证登录
2. 基于密钥的验证-需要在本地生成密钥对，然后把密钥对中的公钥上传至服务器，并与服务器中的公钥进行比较。

由于 linux 中一切皆文件，因此在 linux 系统中修改服务程序的运行参数，实际上就是在修改程序配置文件的过程，sshd 服务的配置信息保存在/etc/ssh/sshd_config 文件中

一般的服务程序并不会在配置文件修改之后立即获得最新的参数，如果想让新配置文件生效，则需要手动重启相应的服务程序，最好也将这个服务程序加入开机启动项中，这样系统在下一次启动时，该服务程序便会自动运行，继续为用户提供服务。

生成密钥对步骤：

1. 在客户端主机中生成密钥对`ssh-keygen`根据提示操作即可，设置保存路径及密码，如果路径中有重复的，需要在其他目录保存
2. 把客户端主机中生成的公钥文件传输到远程主机
3. 对服务器进行设置，使其只允许密钥验证，拒绝传统的口令验证方式，记得在修改配置文件后保存并重启 sshd 服务程序。
4. 在客户端尝试登陆到远程服务器，此时无需输入密码也可以登陆成功

```bash
# 查看ssh服务有没有运行（有则显示如下，每个进程名为sshd）
ps -ef | grep ssh
# root      2458     1  0 02:09 ?        00:00:00 sshd: root@pts/0
# root      2696     1  0 02:41 ?        00:00:00 sshd: root@pts/1
# ...省略一部分
# root      3283     1  0 03:51 ?        00:00:00 /usr/sbin/sshd -D
# root      3301  3283  0 03:51 ?        00:00:00 sshd: root@pts/7

# 查看ssh服务的网络连接情况
netstat -ntlp
# Active Internet connections (only servers)
# Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name
# tcp        0      0 127.0.0.1:25            0.0.0.0:*               LISTEN      1380/exim4
# tcp        0      0 0.0.0.0:53179           0.0.0.0:*               LISTEN      1848/ss-server
# tcp        0      0 0.0.0.0:26947           0.0.0.0:*               LISTEN      3283/sshd
# tcp        0      0 127.0.0.1:3306          0.0.0.0:*               LISTEN      1023/mysqld
# tcp        0      0 0.0.0.0:44397           0.0.0.0:*               LISTEN      576/rpc.statd
# tcp        0      0 0.0.0.0:111             0.0.0.0:*               LISTEN      567/rpcbind
# tcp        0      0 0.0.0.0:80              0.0.0.0:*               LISTEN      660/nginx -g daemon
# tcp6       0      0 ::1:25                  :::*                    LISTEN      1380/exim4
# tcp6       0      0 :::26947                :::*                    LISTEN      3283/sshd
# tcp6       0      0 :::60971                :::*                    LISTEN      576/rpc.statd
# tcp6       0      0 :::111                  :::*                    LISTEN      567/rpcbind
# tcp6       0      0 :::80                   :::*                    LISTEN      660/nginx -g daemon

# ufw防火墙配置
# 可以ufw -h查看每个命令的意思，可以配置拦截端口
# 查看哪些端口被允许(下面显示ufw开启，且允许22和80端口通过)
ufw status
# Status: active

# To                         Action      From
# --                         ------      ----
# 22                         ALLOW       Anywhere
# 80                         ALLOW       Anywhere
# 22                         ALLOW       Anywhere (v6)
# 80                         ALLOW       Anywhere (v6)

# 远程服务器的rsa公钥，多个公钥，换行即可
cat .ssh/authorized_keys
# ssh-rsa AAAxxxx
# ssh-rsa Addxxxx

# 开启公钥登录方式(注意是sshd)
cat /etc/ssh/sshd_config
# RSAAuthentication yes
# PubkeyAuthentication yes
# AuthorizedKeysFile .ssh/authorized_keys
# Port 26947
```

**远程传输命令**:  
scp（secure copy）是一个**基于 ssh 协议在网络间进行安全传输的命令**，其格式:
`scp [参数] 本地文件 远程账户@远程ip地址:远程目录`

**cp 只能在本地硬盘中进行文件复制，而 scp 不仅能够通过网络传送数据，而且所有的数据都将进行加密处理**，例如，如果想把一些文件通过网络从一台主机传递到其他主机，这两台主机又恰巧是 linux 系统，这时使用 scp 命令就可以轻松完成文件的传递了。

```bash
# 因为scp默认连接的是22端口，如果想连接其他端口，则需要-P配置端口号。
scp -P 26947 /Users/finup/Desktop/aa.txt xxx.xx:/home/
# 还需要输入远程服务器中root管理员的密码。
```

**ssh 连接失败**:

```bash
# 如下，当用一台新的电脑远程登录时，会提示如下：
[root@yl-web ~]# ssh root@10.1.101.35
ssh_exchange_identification: read: Connection reset by peer
[root@yl-web ~]# ping 10.1.101.35
PING 10.1.101.35 (10.1.101.35) 56(84) bytes of data.
64 bytes from 10.1.101.35: icmp_seq=1 ttl=64 time=0.587 ms
# ping时网络层的协议，而ssh是应用层的协议，因此还得从主机上找原因

# 排错步骤：
# 可以用ssh -v 连接有问题的服务器，会显示具体的错误日志
# 其实很多命令都接受 -v 或 --verbose参数，表示详情
ssh -v root@10.1.101.35
# 参考：http://yanue.net/post-163.html
# 参考：https://www.cnblogs.com/starof/p/4709805.html
```

##### 防火墙

防火墙有硬件和软件之分，但主要功能都是依据策略对穿越防火墙自身的流量进行过滤。防火墙策略可以基于流量的源目的地，端口号，协议，应用等信息来定制，然后防火墙使用定制的策略规则监控出入的流量。

在 RHEL7 中，firewalld 防火墙取代了 iptables 防火墙，其实 ipatbles 和 firewalld 都不是真正的防火墙，他们都是用来定义防火墙策略的防火墙管理工具而已。或者说，他们只是一种服务。iptables 服务会把配置好的防火墙策略交由内核层面的 netfilter 网络过滤器来处理，而 firewalld 服务则把配置好的防火墙策略交由内核层面的 nftables 包过滤框架来处理。

换句话说，当前在 linux 系统其实存在多个防火墙管理工具，旨在方便运维人员管理 linux 系统的防火墙策略，我们只需要配置其中的一个就足够。

在早期的 linux 系统中，默认使用的 iptables 防火墙管理服务来配置防火墙，尽管新型的 firewalld 防火墙管理服务已经投入使用多年，但大量的企业在生产环境中依然出于各种原因而继续使用 iptales。

**策略与规则链**：  
防火墙从上至下的顺序来读取配置的策略规则，在找到匹配项后就立即结束匹配工作并去执行匹配项中定义的行为（放行或阻止），如果再读取完所有的策略规则之后没有匹配项，就去执行默认的策略。

iptables 服务把用于处理或过滤流量的策略条目称之为规则，多条规则可以组成一个规则链，而规则链则依据数据包处理位置的不同进行分类。有以下分类：

1. 在进行路由选择前处理数据包（prerouting）
2. 处理流入的数据包 input
3. 处理流出的数据包 output
4. 处理转发的数据包 forward
5. 在进行路由选择后处理数据包 postrouting
   一般来说，从内网向外网发送的流量一般都是可控且良性的，因此我们使用最多的就是 input 链，该规则链可以增大黑客人员从外网入侵内网的难度。

#### 独立服务器，虚拟主机，vps，云主机

##### 基本概念

主要是因为刚开始的物理机很大程度上都做不到最大化的利用，因此通过虚拟化技术或容器技术将物理机虚拟出很多独立运行的操作系统。

- 独立服务器，顾名思义，就是一个躺在机房的实实在在的物理服务器，也可理解为你的游戏主机一样。
- VPS（Virtual Private Server）虚拟专用服务器,一般是将一个独立服务器通过虚拟化技术虚拟成多个虚拟专用服务器。
- 云服务器 Elastic Compute Service, 简称 ECS 好多人理解云服务器和 VPS 一样，更有甚者说以前的 VPS 现在的说法就是云服务器，其实不然，云服务器是一个计算，网络，存储的组合。简单点说就是通过多个 CPU，内存，硬盘组成的计算池和存储池和网络的组合。
- Virtual hosts （Vhost）虚拟主机是通过，物理服务器，VPS 或者云服务器安装例如 CPanel，Plesk 等面板搭建的。

虚拟主机可以想象成租的一个床位，而 vps 可以想象成买的公寓，前者只有使用权，没有装修改造权，而后者都具有。。。但 vps 不能随意扩容，想扩容则需要重新买。。。而云服务器则可以根据需要自动扩容

如果每台运行的 linux 系统的服务器只能运行一个网站，会造成硬件资源的浪费，在虚拟专用服务器 vps(virtual private server )与云技术诞生以前，IDC 服务供应商为了能够更充分利用服务器资源，同时也为了降低购买门槛，于是纷纷启用了虚拟主机。

利用虚拟主机功能，可以把一台处于运行状态的物理服务器分割成多个虚拟的服务器，但是，该技术无法实现目前云主机技术的硬件资源隔离，让这些虚拟的服务器共同使用物理服务器的硬件资源，供应商只能限制硬盘的使用空间大小，处于考虑的因素（主要是价格低廉），目前依然有很多企业或个人站长在使用虚拟主机的形式来部署网站。

web 网络服务是一种被动访问的服务程序，即只有接收到互联网中其他主机发出的请求后才会响应，最终用于提供服务程序的 web 服务器会通过 http 超文本传输协议或 https 安全超文本传输协议，把请求的内容传送给用户。

目前提供 web 网络服务的程序有 IIS，Ngnix 和 apache 等，其中，IIS（Internet Information Services，互联网信息服务）是 Windows 系统中默认的 Web 服务程序，这是一款图形化的网站管理工具，不仅可以提供 Web 网站服务，还可以提供 FTP、NMTP、SMTP 等服务。但是，IIS 只能在 Windows 系统中使用。

Apache 服务程序可以运行在 Linux 系统、UNIX 系统甚至是 Windows 系统中，支持基于 IP、域名及端口号的虚拟主机功能，支持多种认证方式，集成有代理服务器模块、安全 Socket 层（SSL），能够实时监视服务状态与定制日志消息，并有着各类丰富的模块支持。apache 也是一个服务程序，可以运行在 linux，windows 上。

##### 虚拟机通信

vm 虚拟机软件为用户提供了 3 中可选的网络模式，分别为桥接模式，nat 模式与仅主机模式

- 桥接模式：相当于在物理主机与虚拟机网卡之间架设了一座桥梁，从而可以通过物理主机的网卡访问外网
- NAT 模式：让 vm 虚拟机的网络服务发挥路由器的作用，使得通过虚拟机软件模拟的主机可以通过物理主机访问外网，在真机中 NAT 虚拟网卡对应的物理网卡是 VMnet8
- 仅主机模式：仅让虚拟机内的主机与物理主机通信，不能访问外网，在真机中仅主机模式模拟网卡对应的物理网卡是 VMnet1

#### 链接

[vicommonuseurl]: http://c.biancheng.net/cpp/html/2735.html
[chomduseurl]: http://www.runoob.com/linux/linux-comm-chmod.html
[macenviromentset]: http://www.runoob.com/linux/linux-comm-chmod.html
[mirrorconfigchinaurl]: https://www.npmjs.com/package/mirror-config-china
[cnodesaynpmurl]: https://cnodejs.org/topic/552212ba01b6c9310d8e9959
[changenpmregistry]: https://sebastianblade.com/the-truly-way-to-install-upgrade-npm-dependency-in-china/
